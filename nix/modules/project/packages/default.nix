# Definition of the `haskellProjects.${name}` submodule's `config`
project@{ name, lib, pkgs, ... }:
let
  inherit (lib)
    types;

  packageSubmodule = import ./package.nix { inherit project lib pkgs; };

  # Merge the list of attrset of modules.
  mergeModuleAttrs =
    lib.zipAttrsWith (k: vs: { imports = vs; });

  tracePackages = k: x:
    project.config.log.traceDebug "${k} ${builtins.toJSON x}" x;
in
{
  options = {
    packages = lib.mkOption {
      type = types.lazyAttrsOf types.deferredModule;
      default = { };
      apply = packages:
        let
          packages' =
            # Merge user-provided 'packages' with 'defaults.packages'. 
            #
            # Note that the user can override the latter too if they wish.
            mergeModuleAttrs
              [ project.config.defaults.packages packages ];
        in
        tracePackages "${name}.packages:apply" (
          lib.mapAttrs
            (name: v:
              (lib.evalModules {
                modules = [ packageSubmodule v ];
                specialArgs = { inherit name pkgs; };
              }).config
            )
            packages');

      description = ''
        Additional packages to add to `basePackages`.

        Local packages are added automatically (see `config.defaults.packages`):

        You can also override the source for existing packages here.
      '';
    };

    packagesOverlay = lib.mkOption {
      type = import ../../../types/haskell-overlay-type.nix { inherit lib; };
      description = ''
        The Haskell overlay computed from `packages` modules.
      '';
      internal = true;
      default = self: _super:
        let
          inherit (project.config) log;
          build-haskell-package = import ../../../build-haskell-package.nix {
            inherit pkgs lib self log;
          };
          callPackageKeepDeriver = src: args:
            pkgs.haskell.lib.compose.overrideCabal
              (orig: {
                passthru = orig.passthru or { } // {
                  # When using callCabal2nix or callHackage, it is often useful
                  # to debug a failure by inspecting the Nix expression
                  # generated by cabal2nix. This can be accessed via this
                  # cabal2nixDeriver field.
                  cabal2nixDeriver = src;
                };
              })
              (self.callPackage src args);
          getOrMkPackage = name: cfg:
            if lib.types.path.check cfg.source
            then
              log.traceDebug "${name}.callCabal2nix[cached] ${cfg.source}"
                (build-haskell-package name cfg.source "${project.config.projectRoot}/.haskellSrc2nix/${name}.nix")
            else
              log.traceDebug "${name}.callHackage[cached] ${cfg.source}"
                (
                  # (self.callHackage name cfg.source { })
                  # callPackageKeepDeriver (self.hackage2nix name cfg.source) {}
                  callPackageKeepDeriver "${project.config.projectRoot}/.haskellSrc2nix/${name}.nix" { }
                );
        in
        lib.mapAttrs getOrMkPackage project.config.packages;
    };

    # cabal2nix generated Nix expressions for packages
    # uses `hackage2nix`
    packagesNix = lib.mkOption {
      default =
        lib.mapAttrs
          (name: cfg:
            let
              self = project.config.basePackages;
              callCabal2nixWithOptionsExr = name: src: extraCabal2nixOptions:
                let
                  filter = path: type:
                    pkgs.lib.hasSuffix ".cabal" path ||
                    baseNameOf path == "package.yaml";
                in
                self.haskellSrc2nix {
                  inherit name extraCabal2nixOptions;
                  src =
                    if pkgs.lib.canCleanSource src
                    then pkgs.lib.cleanSourceWith { inherit src filter; }
                    else src;
                };
              readCabal2NixExpr = drv:
                "${builtins.trace drv.outPath drv}/default.nix";
            in
            readCabal2NixExpr (if lib.types.path.check cfg.source
            # FIXME: Patch `src` to not point to nix store.
            then callCabal2nixWithOptionsExr name cfg.source ""
            else self.hackage2nix name cfg.source)
          )
          project.config.packages;
    };
  };
}
