---
slug: docker
---

# Building a docker image

A flake-parts module can be created to build a docker image that packages your haskell project's outputs.

Consider a haskell-flake project. To copy the binaries generated by the `default` package to `/bin` on the image,  one can use `copyToRoot` attribute offered by `dockerTools.buildImage`. For example:

```nix
{
  # Inside perSystem.packages' `dockerImage`:
  pkgs.dockerTools.buildImage {
    name = "foo";
    copyToRoot = pkgs.buildEnv {
      paths = with pkgs; [
        self'.packages.default
      ];
      name = "foo-root";
      pathsToLink = [ "/bin" ];
    };
  };
}
```
Assuming you have defined an attribute `packages.all` that builds your multi-package haskell project. `self'.packages.default` can be replaced with `self'.packages.all` to copy all the binaries onto the image.

It is not just limited to `packages` built by the current project, one can also have other packages and copy subdirectories of the current project. `self` can be added to `paths` to expose the project directory. 
```nix
{
  copyToRoot = pkgs.buildEnv {
    paths = with pkgs; [
      coreutils
      bash
      self
    ];
    name = "foo-root";
    pathsToLink = [ "/foo_sub" "/bin" ];
  };
}
```
If you'd like your docker image to run your haskell project's default package when the container starts, use the following config:
```nix
{
  # Inside dockerImage's `buildImage`
  config = {
    Cmd = [ "${pkgs.lib.getExe self'.packages.default}" ];
  };
}
```

Finally, add your flake-parts module to your `flake.nix`.
```nix
{
  # Inside flake-parts' `mkFlake`:
  imports = [
      ./nix/docker.nix
  ];
}
```

## Tips

If you don't want `docker images` showing that the image was created several decades ago, use the following:
```nix
{
  # Inside perSystem.packages' `dockerImage`:
  pkgs.dockerTools.buildImage {
    name = "foo";
    created = "now";
  };
}
```

Several times one would also like to tag their images with the commit id of the working copy. This can achieved as follows:

```nix
{
  # Inside perSystem.packages' `dockerImage`:
  pkgs.dockerTools.buildImage {
    name = "foo";
    tag = builtins.substring 0 9 (self.rev or "dev");
  };
}
```
`builtins.substring 0 9 self.rev` is the same as `git rev-parse --short HEAD`. `self.rev` is non-null only on a clean working copy and hence the tag is set to `dev` when the working copy is dirty.


## Example

- [Sample flake-parts module for docker](https://github.com/nammayatri/nammayatri/pull/14/files#diff-18ea3dd9a6a84702796b8dac608d0cad8e396a7c2e8c52732fcb7e5f52d1b0b9)
